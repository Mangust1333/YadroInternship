# Решение

Проект реализован на языке C++20 и использует систему автоматизации сборки CMake.
Входной точкой программы является файл main.cpp, который расположен в каталоге Presentation.
Для запуска необходимо дополнить следующим параметром *-f ../input/test_file.txt*.
## Шаги для запуска
Пример:
1) Перейдите в директорию с проектом, где находится файл CMakeLists.txt.
2) Сгенерируйте и постройте проект с помощью выбранного инструмента сборки.
Например, с помощью CMake это может быть:
```bash
  cmake -S . -B build
  cmake --build build
```
3) Для запуска программы используйте следующий командный синтаксис: ./build/task -f ../input/test_file.txt<br>
Где:
* -f — флаг, указывающий путь к файлу с входными данными.
* task.exe — это собранный исполняемый файл.

## Архитектура
Программа спроектирована с использованием *луковой архитектуры* (onion architecture). Это позволяет обеспечить высокую степень независимости и тестируемости компонентов системы, а также гибкость и простоту в изменениях и добавлениях функционала. Луковая архитектура включает следующие слои:

1) *Внешний слой (Presentation)* — это слой, который отвечает за взаимодействие с пользователем и ввод/вывод данных. В данном случае он включает в себя точку входа в программу, где обрабатываются командные аргументы, а также реализуется вывод результата работы системы.
2) *Слой сервисов (Services)* — слой, который инкапсулирует бизнес-логику. Здесь обрабатываются все события, связанные с клиентами, столами и вычислением выручки. Логика работы с данными, обработка ошибок и управление состоянием системы происходят в этом слое.
3) *Слой домена (Domain)* — этот слой содержит модели данных, такие как объекты событий, столов и клиентов. Также в этом слое могут находиться интерфейсы, которые предоставляют бизнес-логику для сервисного слоя.
4) *Внутренний слой (Infrastructure)* — слой, обеспечивающий взаимодействие с внешними системами, такими как файловый парсер, работа с аргументами командной строки и другие технические аспекты реализации. Он взаимодействует с сервисами и доменом через четко определенные интерфейсы.
5) *Tests* — директория с тестами, которые можно запустить для проверки корректности работы системы.

Эта архитектура позволяет минимизировать зависимости между различными компонентами системы, улучшая поддержку и расширяемость приложения.

## Требования к запуску:
Программа должна компилироваться и корректно работать как на Linux, так и на Windows (с использованием MinGW или Cygwin).
Необходимо использовать компиляторы gcc или clang для Linux и MinGW/Cygwin для Windows.

## Система сборки:
Система сборки использует CMake, что позволяет автоматически настроить проект на любой платформе, поддерживающей CMake.

# Техническое Задание

**Требуется написать прототип системы, которая следит за работой компьютерного клуба, обрабатывает события и подсчитывает выручку за день и время занятости каждого стола.**

# Требования к решению

## C++
Решением задания будет: файл или несколько файлов с исходным кодом программы на языке **C++ (стандарт до C++20 включительно)**, инструкции по сборке и тестовые примеры (количество тестов – на усмотрение разработчика). 

## Входные данные
Входные данные представляют собой текстовый файл. Файл указывается первым аргументом при запуске программы. Пример запуска программы: 
$ task.exe test_file.txt

## Компилятор
Программа должна компилироваться компилятором gcc или clang в Linux, mingw/cygwin в Windows. 
В решении, кроме файлов с исходным кодом, требуется предоставить инструкции по компиляции программы для проверки. Можно, но необязательно, использовать следующие системы автоматизации сборки: make, automake, cmake, gradle; проприетарные средства сборки не допускаются: например, файлы проектов MS Visual Studio не подойдут.

## Библиотеки
Рекомендуется использование **стандартной библиотеки (STL)**. Использование любых сторонних библиотек, кроме **STL**, запрещено.

## Тестирование
Можно (но необязательно) написать проверочные юнит-тесты с использованием доступной библиотеки (Google Test, CppUTest, и т.п.).


# Формат входных данных
<количество столов в компьютерном клубе><br>
<время **начала** работы> <время **окончания** работы><br>
<стоимость часа в компьютерном клубе><br>
<время события 1> <идентификатор события 1> <тело события 1><br>
<время события 2> <идентификатор события 2> <тело события 2><br>
...<br>
<время события N> <идентификатор события N> <тело события N><br>

Первая строка содержит количество столов в виде целого положительного числа.
Во второй строке задается время **начала** и **окончания** работы компьютерного клуба, **разделенные пробелом**.
В третьей строке задается стоимость часа в компьютерном клубе в виде **целого положительного числа**.
Затем задается список входящих событий, разделенных **переносом строки**. Внутри строки в качестве **разделителя** между элементами используется **один пробел**.

*	Имена клиентов представляют собой комбинацию символов из алфавита a..z, 0..9, _, -
*	Время задается в 24-часовом формате с двоеточием в качестве разделителя XX:XX, незначащие нули обязательны при вводе и выводе (например 15:03 или 08:09).
*	Каждый стол имеет свой номер от 1 до N, где N – общее число столов, указанное в конфигурации.
*	Все события идут последовательно во времени. (время события N+1) ≥ (время события N).

# Выходные данные
Если входные данные не удовлетворяют описанному формату, программа должна вывести в консоль **первую строку**, в которой найдена ошибка формата и **завершиться**.

Если входные данные корректны, программа должна вывести следующий результат:
* На первой строке выводится время начала работы.
* Далее перечислены все события, произошедшие за рабочий день (входящие и исходящие), каждое на отдельной строке.
* После списка событий на отдельной строке выводится время окончания работы.
* Для каждого стола на отдельной строке выведены через пробел следующие параметры: Номер стола, Выручка за день и Время, которое он был занят в течение рабочего дня.

После этого программа должна **завершиться**.

# Подсчет выручки
За каждый час, проведённый за столом, клиент платит цену, указанную в конфигурации. При оплате время округляется до часа в большую сторону, поэтому, даже если клиент занимал стол всего несколько минут, он платит за целый час. Выручка – сумма, полученная ото всех клиентов за всё время работы компьютерного клуба.

# События
Все события характеризуются временем и идентификатором события. Исходящие события — это события, создаваемые во время работы программы. События, относящиеся к категории «входящие», сгенерированы быть не могут, и выводятся в том же виде, в котором были поданы во входном файле.

# Входящие события:
## ID 1. Клиент пришел
Формат: <время> 1 <имя клиента><br>
Если клиент уже в компьютерном клубе, генерируется ошибка "YouShallNotPass"<br>
Если клиент пришел в нерабочие часы, тогда "NotOpenYet"
## ID 2. Клиент сел за стол 
Формат: <время> 2 <имя клиента> <номер стола><br>
Если клиент уже сидит за столом, то он может сменить стол.<br>
Если стол <номер стола> занят (в том числе, если клиент пытается пересесть за стол, за которым сам и сидит), генерируется ошибка "PlaceIsBusy".<br>
Если клиент не находится в компьютерном клубе, генерируется ошибка "ClientUnknown".
## ID 3. Клиент ожидает
Формат: <время> 3 <имя клиента>
Если в клубе есть свободные столы, то генерируется ошибка "ICanWaitNoLonger!".
Если в очереди ожидания клиентов больше, чем общее число столов, то клиент уходит и генерируется событие ID 11.
## ID 4. Клиент ушел
Формат: <время> 4 <имя клиента><br>
Если клиент не находится в компьютерном клубе, генерируется ошибка "ClientUnknown".<br>
Когда клиент уходит, стол, за которым он сидел освобождается и его занимает первый клиент из очереди ожидания (ID 12).

# Исходящие события:
## ID 11. Клиент ушел
Формат: <время> 11 <имя клиента><br>
Генерируется в конце рабочего дня для всех клиентов, оставшихся в компьютерном клубе, **в алфавитном порядке их имен**. А также, когда клиент встает в очередь, а очередь ожидания уже заполнена.
## ID 12. Клиент сел за стол 
Формат: <время> 12 <имя клиента> <номер стола><br>
Генерируется для первого клиента в очереди при освобождении любого стола.
## ID 13. Ошибка
Формат: <время> 13 <ошибка><br>
Выводится сразу после события, которое вызвало ошибку. Событие, вызвавшее ошибку, считается не выполненным, и никакого эффекта на состояние клиентов не оказывает.

## Пример работы программы:
| Входной файл      | Вывод в консоль            |
|-------------------|----------------------------|
| 3                 | 09:00                      |
| 09:00 19:00       | 08:48 1 client1            |
| 10                | 08:48 13 NotOpenYet        |
| 08:48 1 client1   | 09:41 1 client1            |
| 09:41 1 client1   | 09:48 1 client2            |
| 09:48 1 client2   | 09:52 3 client1            |
| 09:52 3 client1   | 09:52 13 ICanWaitNoLonger! |
| 09:54 2 client1 1 | 09:54 2 client1 1          |
| 10:25 2 client2 2 | 10:25 2 client2 2          |
| 10:58 1 client3   | 10:58 1 client3            |
| 10:59 2 client3 3 | 10:59 2 client3 3          |
| 11:30 1 client4   | 11:30 1 client4            |
| 11:35 2 client4 2 | 11:35 2 client4 2          |
| 11:45 3 client4   | 11:35 13 PlaceIsBusy       |
| 12:33 4 client1   | 11:45 3 client4            |
| 12:43 4 client2   | 12:33 4 client1            |
| 15:52 4 client4   | 12:33 12 client4 1         |
|                   | 12:43 4 client2            |
|                   | 15:52 4 client4            |
|                   | 19:00 11 client3           |
